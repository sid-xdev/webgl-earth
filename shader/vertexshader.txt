uniform mat4 uPerspMat;
uniform mat4 uCameraMat; 
uniform mat4 uTransfMat;
uniform int uSwitchTrns;

attribute vec3 aVertexPos; 
attribute vec3 aVertexNorm;
attribute vec2 aVertexUV;

attribute vec3 a1Column;
attribute vec3 a2Column;
attribute vec3 a3Column;
attribute vec3 a4Column; 

varying vec4 vVertexPos;
varying vec3 vVertexNorm;
varying vec3 vCameraPos;
varying vec2 vVertexUV;  
  
float det( mat3 a )
{ 
	return (  a[0][0]*a[1][1]*a[2][2]
			+ a[1][0]*a[2][1]*a[0][2]
			+ a[2][0]*a[0][1]*a[1][2]
			- a[2][0]*a[1][1]*a[0][2]
			- a[1][0]*a[0][1]*a[2][2]
			- a[0][0]*a[2][1]*a[1][2]); 
} 
  
mat3 invert( mat3 m )  
{ 
	float a = m[0][0]; 
	float b = m[1][0]; 
	float c = m[2][0]; 
	float d = m[0][1]; 
	float e = m[1][1]; 
	float f = m[2][1]; 
	float g = m[0][2]; 
	float h = m[1][2]; 
	float i = m[2][2]; 
	return det( m ) * mat3(e*i-f*h, f*g-d*i, d*h-e*g, 
						   c*h-b*i, a*i-c*g, b*g-a*h, 
						   b*f-c*e, c*d-a*f, a*e-b*d); 
} 

mat3 transp( mat3 m )  
{ 
	return mat3( 	vec3(m[0][0], m[1][0], m[2][0]),
					vec3(m[0][1], m[1][1], m[2][1]),
					vec3(m[0][2], m[1][2], m[2][2]) ); 
}

mat4 transp( mat4 m )  
{ 
	return mat4( 	vec4(m[0][0], m[1][0], m[2][0], m[3][0]), 
					vec4(m[0][1], m[1][1], m[2][1], m[3][1]),
					vec4(m[0][2], m[1][2], m[2][2], m[3][2]),
					vec4(m[0][3], m[1][3], m[2][3], m[3][3]) ); 
}

mat4 rotate( float a , vec3 n)
{
	a = radians(a);
	float cas = 1.0-cos(a);
	return mat4( n[0]*n[0]*cas+cos(a), n[1]*n[0]*cas+n[2]*sin(a), n[0]*n[2]*cas-n[1]*sin(a), 0.0,
		         n[0]*n[1]*cas- n[2]*sin(a), n[1]*n[1]*cas+cos(a), n[2]*n[1]*cas+n[0]*sin(a), 0.0,
		         n[0]*n[2]*cas+n[1]*sin(a), n[1]*n[2]*cas-n[0]*sin(a), n[2]*n[2]*cas+cos(a), 0.0,
				 0.0, 0.0, 0.0, 1.0);
}

void main() 
{ 
	vVertexUV = aVertexUV;  
	mat4 tMatVertex;
	if(uSwitchTrns == 1)
	{
		tMatVertex = mat4( vec4( a1Column, 0.0 ),
								vec4( a2Column, 0.0 ),
								vec4( a3Column, 0.0 ),
								vec4( a4Column, 1.0 ));
	}
	else
	{
		tMatVertex = uTransfMat;
	}
	
	mat3 cRot = invert( mat3(uCameraMat) );
	vec3 cTra = (-cRot)*vec3(uCameraMat[3]);
	mat4 tMatCamera = mat4( vec4(cRot[0], 0.0),
							vec4(cRot[1], 0.0),
							vec4(cRot[2], 0.0),		
							vec4(cTra, 1.0) );
	vCameraPos = vec3( tMatCamera[3] );						
	vVertexPos = tMatCamera * tMatVertex * vec4( aVertexPos, 1.0 ); 
	gl_Position = uPerspMat * vVertexPos; 
	mat3 normalMat = transp( invert( mat3( tMatCamera * tMatVertex ) ) ); 
	vVertexNorm = normalMat * normalize( aVertexNorm ); 
}