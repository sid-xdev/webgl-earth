precision lowp float;

uniform int uGlowState;
uniform int uLightState;

uniform vec3 uLightPosition;
uniform vec3 uLightColor;
uniform vec3 uAmbLightColor;
uniform vec3 uGlowColor;

uniform vec2 uTexDiffusOffset;
uniform vec2 uTexTransparentOffset;
uniform vec2 uTexNormalOffset;
uniform vec2 uTexSpecularOffset;
uniform vec2 uTexReflectionOffset;

uniform sampler2D uTexDiffusSampler;
uniform sampler2D uTexTransparentSampler;
uniform sampler2D uTexNormalSampler;
uniform sampler2D uTexSpecularSampler;
uniform sampler2D uTexReflectionSampler;
uniform sampler2D uTexGlowSampler;

varying mat4 vCameraMat;
varying vec3 vVertexNorm; 
varying vec4 vVertexPos;
varying vec2 vVertexUV;  


vec4 bump( float multi ,sampler2D sampler, vec2 uv )
{
	vec2 size = vec2( 1.0/multi, 0.0 );
	
    vec4 center = texture2D( sampler, uv );
    float s11 = center.x;
    float s01 = texture2D( sampler, vec2( uv.x - 0.000244, uv.y ) ).x;
    float s21 = texture2D( sampler, vec2( uv.x + 0.000244, uv.y ) ).x;
    float s10 = texture2D( sampler, vec2( uv.x, uv.y - 0.000488 ) ).x;
    float s12 = texture2D( sampler, vec2( uv.x, uv.y + 0.000488 ) ).x;
    vec3 va = normalize( vec3( size.xy, s21 - s01 ) );
    vec3 vb = normalize( vec3( size.yx, s12 - s10 ) );
    return vec4( cross( va, vb ), s11 );
}

void main()
{
	float rad = 17.4;
	vec3 normal = normalize( vVertexNorm + bump( 10.0 ,uTexNormalSampler, mod( vVertexUV*uTexNormalOffset, 1.0 ) ).rgb );
	vec3 lightpos = vec3( vCameraMat * vec4( uLightPosition + rad*normal, 1.0 ) );
	vec3 lightDirection = normalize( lightpos - vec3( vVertexPos ) );
	vec3 eyeDirection = normalize( -vVertexPos.xyz );
	
	
	gl_FragColor = texture2D( uTexDiffusSampler, vVertexUV*uTexDiffusOffset );
	
	if( uGlowState == 1 )
	{
		gl_FragColor = texture2D( uTexGlowSampler, vVertexUV );
		return;
	}
	
	if( uGlowState == 0 )
	{
		if( uLightState == 1 )
		{
			vec3 reflDirection = reflect( -lightDirection, normal );
			vec3 diffus = ( uAmbLightColor + uLightColor * max( dot( normal, lightDirection ), 0.0 ) ) * texture2D( uTexDiffusSampler, vVertexUV*uTexDiffusOffset ).rgb;
			vec3 spec = ( uLightColor + uAmbLightColor ) * pow( max( dot( eyeDirection, reflDirection ), 0.0 ), 100.0 ) * texture2D( uTexSpecularSampler, vVertexUV*uTexSpecularOffset ).rgb;
			vec3 night = 10.0 * max( 0.15 - max( dot( vVertexNorm, lightDirection ), 0.0 ), 0.0 ) * texture2D( uTexReflectionSampler, vVertexUV*uTexReflectionOffset ).rgb;
			vec3 transp = vec3( texture2D( uTexTransparentSampler, vVertexUV*uTexTransparentOffset ) );
			float alpha = ( transp.r + transp.g + transp.b )/3.0;
			
			gl_FragColor = vec4( diffus + spec + night, alpha );
		}
		else
		{
			gl_FragColor = texture2D( uTexDiffusSampler, vVertexUV*uTexDiffusOffset );
		}
	}
}